<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>TOOL T√ÄI X·ªàU - ENSEMBLE STRATEGY FIXED</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      padding: 20px;
    }
    #history .session {
      padding: 8px;
      border-bottom: 1px solid #ccc;
    }
    #nextPrediction {
      font-weight: bold;
      font-size: 20px;
      margin-top: 20px;
      color: #d63384;
    }
    #currentStrategy {
      margin: 10px 0;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>üéØ TOOL SUM ƒê∆Ø·ª¢C B√ìNG X</h2>

  <div id="currentStrategy">‚è≥ ƒêang ph√¢n t√≠ch chi·∫øn l∆∞·ª£c...</div>
  <div id="nextPrediction">ƒêang d·ª± ƒëo√°n...</div>
  <div id="history">ƒêang t·∫£i d·ªØ li·ªáu...</div>
  <canvas id="accuracyChart" width="400" height="200"></canvas>

  <script>
    const TELEGRAM_TOKEN = "7785351537:AAHdxL61w6uRnJnRVkXrIFTfgH1I8fkoAhM";
    const CHAT_IDS = ["-1002723056627"];
    const ADMIN_ID = "6463176046";

    const strategies = ["chain", "frequency", "random"];
    let strategyStats = {
      chain: { correct: 0, total: 0 },
      frequency: { correct: 0, total: 0 },
      random: { correct: 0, total: 0 },
    };

    let lastSentSessionId = null;
    let correct = 0, wrong = 0;
    let lastPrediction = null;
    let lastPredictionSessionId = null;
    let isBotEnabled = true;

    const ctx = document.getElementById('accuracyChart').getContext('2d');
    const accuracyChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'ƒê·ªô ch√≠nh x√°c (%)',
          data: [],
          borderColor: 'green',
          fill: false
        }]
      }
    });

    function updateChart(sessionId, accuracy) {
      accuracyChart.data.labels.push(sessionId.toString());
      accuracyChart.data.datasets[0].data.push(accuracy);
      accuracyChart.update();
    }

    function getResult(sum) {
      return sum >= 11 ? 'T√†i' : 'X·ªâu';
    }

    function getVNTime() {
      const now = new Date();
      now.setHours(now.getHours() + 7);
      return now.toTimeString().split(' ')[0] + ' - ' + now.toLocaleDateString('vi-VN');
    }

    function predictByStrategy(data, strategy) {
      if (strategy === "frequency") {
        const counts = { T√†i: 0, X·ªâu: 0 };
        data.forEach(item => {
          const sum = item.FirstDice + item.SecondDice + item.ThirdDice;
          counts[getResult(sum)]++;
        });
        return counts['T√†i'] >= counts['X·ªâu'] ? 'T√†i' : 'X·ªâu';
      } else if (strategy === "chain") {
        const latest = getResult(data[0].FirstDice + data[0].SecondDice + data[0].ThirdDice);
        return latest === 'T√†i' ? 'X·ªâu' : 'T√†i';
      } else {
        return Math.random() < 0.5 ? 'T√†i' : 'X·ªâu';
      }
    }

    function getFinalPrediction(data) {
      const votes = { T√†i: 0, X·ªâu: 0 };
      const individualPredictions = {};

      strategies.forEach(strategy => {
        const result = predictByStrategy(data, strategy);
        votes[result]++;
        individualPredictions[strategy] = result;
      });

      const finalPrediction = votes['T√†i'] > votes['X·ªâu'] ? 'T√†i' :
                              votes['X·ªâu'] > votes['T√†i'] ? 'X·ªâu' :
                              Math.random() < 0.5 ? 'T√†i' : 'X·ªâu';

      return { finalPrediction, individualPredictions };
    }

    async function fetchData() {
      try {
        const res = await fetch('https://taixiu1.gsum01.com/api/luckydice1/GetSoiCau');
        const data = await res.json();
        return data.slice(0, 10);
      } catch (e) {
        console.error('L·ªói khi l·∫•y API:', e);
        return [];
      }
    }

    function displayHistory(data) {
      const historyDiv = document.getElementById('history');
      historyDiv.innerHTML = '';
      data.forEach(item => {
        const sum = item.FirstDice + item.SecondDice + item.ThirdDice;
        const result = getResult(sum);
        historyDiv.innerHTML += `
          <div class="session">
            <b>Phi√™n ${item.SessionId}</b>: üé≤ ${item.FirstDice}-${item.SecondDice}-${item.ThirdDice} = <b>${sum}</b> ‚ûú <b>${result}</b>
          </div>
        `;
      });
    }

    async function sendTelegramMessage(message) {
      const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
      for (const chat_id of CHAT_IDS) {
        try {
          await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id,
              text: message,
              parse_mode: "Markdown"
            })
          });
        } catch (e) {
          console.error("L·ªói g·ª≠i Telegram:", e);
        }
      }
    }

    async function checkTelegramCommand() {
      try {
        const res = await fetch(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/getUpdates`);
        const data = await res.json();
        const updates = data.result;
        if (!updates || updates.length === 0) return;

        const latest = updates[updates.length - 1];
        const msg = latest.message;
        if (!msg || msg.from.id.toString() !== ADMIN_ID) return;

        const text = msg.text.toLowerCase();
        if (text === "/on") {
          isBotEnabled = true;
          await sendTelegramMessage("‚úÖ Bot ƒë√£ *b·∫≠t* g·ª≠i d·ª± ƒëo√°n.");
        } else if (text === "/off") {
          isBotEnabled = false;
          await sendTelegramMessage("‚õî Bot ƒë√£ *t·∫Øt* g·ª≠i d·ª± ƒëo√°n.");
        }
      } catch (e) {
        console.error("L·ªói ki·ªÉm tra l·ªánh Telegram:", e);
      }
    }

    async function predictNext(data) {
      const current = data[0];
      const sessionId = current.SessionId;
      const currentResult = getResult(current.FirstDice + current.SecondDice + current.ThirdDice);

      if (lastSentSessionId !== sessionId && isBotEnabled) {
        lastSentSessionId = sessionId;

        let msg = "";

        if (lastPrediction && lastPredictionSessionId === sessionId - 1) {
          const isCorrect = lastPrediction === currentResult;
          if (isCorrect) correct++; else wrong++;

          const accuracy = ((correct / (correct + wrong)) * 100).toFixed(1);
          updateChart(sessionId, accuracy);

          const { finalPrediction, individualPredictions } = getFinalPrediction(data);

          for (const strategy in individualPredictions) {
            const res = individualPredictions[strategy];
            strategyStats[strategy].total++;
            if (res === currentResult) strategyStats[strategy].correct++;
          }

          let strategyDetail = "";
          for (const strategy in individualPredictions) {
            const res = individualPredictions[strategy];
            const sAcc = strategyStats[strategy];
            const acc = sAcc.total > 0 ? ((sAcc.correct / sAcc.total) * 100).toFixed(1) : "0";
            strategyDetail += `- ${strategy}: ${res} (${acc}%)\n`;
          }

          msg = `
üéØ *TOOL T·ªîNG H·ª¢P CHI·∫æN THU·∫¨T* üéØ
üÜî Phi√™n: ${sessionId}
üé≤ K·∫øt qu·∫£: ${current.FirstDice}-${current.SecondDice}-${current.ThirdDice} ‚ûú *${currentResult}*

üìå D·ª± ƒëo√°n phi√™n tr∆∞·ªõc (${lastPredictionSessionId}): *${lastPrediction}* ‚Üí ${isCorrect ? '‚úÖ ƒê√öNG' : '‚ùå SAI'}
üß† D·ª± ƒëo√°n t·ª´ng chi·∫øn thu·∫≠t:
${strategyDetail}
üîÆ D·ª± ƒëo√°n ti·∫øp theo (${sessionId + 1}): *${finalPrediction}*
üìä ƒê·ªô ch√≠nh x√°c t·ªïng: *${accuracy}%* (${correct}/${correct + wrong})
üïí Gi·ªù VN: ${getVNTime()}
          `;
          document.getElementById('nextPrediction').innerText = `üëâ D·ª± ƒëo√°n ti·∫øp theo: ${finalPrediction}`;
          document.getElementById('currentStrategy').innerText = `üß† T·ªïng h·ª£p: ${finalPrediction}`;
          lastPrediction = finalPrediction;
          lastPredictionSessionId = sessionId;
        } else {
          const { finalPrediction } = getFinalPrediction(data);
          lastPrediction = finalPrediction;
          lastPredictionSessionId = sessionId;
          document.getElementById('nextPrediction').innerText = `üëâ D·ª± ƒëo√°n ti·∫øp theo: ${finalPrediction}`;
          document.getElementById('currentStrategy').innerText = `üß† T·ªïng h·ª£p: ${finalPrediction}`;
        }

        if (msg.trim()) await sendTelegramMessage(msg.trim());
      }
    }

    async function main() {
      const data = await fetchData();
      if (data.length > 1) {
        displayHistory(data);
        await predictNext(data);
        await checkTelegramCommand();
      }
    }

    main();
    setInterval(main, 10000);
  </script>
</body>
</html>
